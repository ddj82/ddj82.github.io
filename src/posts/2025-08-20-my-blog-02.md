---
layout: post
title: "React에서 Markdown 렌더링하기 (react-markdown)"
date: 2025-08-20
categories: ["Markdown", "react-markdown", "remark-gfm", "rehype-pretty-code"]
---

안녕하세요 ddj82입니다.

이번 글에서는 **react-markdown**을 활용해 마크다운 파일을 React에서 렌더링하는 방법과, GFM 및 코드 하이라이팅 적용을 통한 커스터마이징 방법을 정리해보겠습니다.

---

## React에서 Markdown 불러오기

React 프로젝트에서 Markdown을 렌더링하는 방법은 크게 두 가지입니다.

### 1) 정적 import 방식 (?raw 옵션)
- **권장 상황**: 문서나 포트폴리오 등 글 개수가 많지 않은 경우
- **장점**
    - 네트워크 요청이 없어 빠른 렌더링
    - 코드 구조가 단순하고 유지보수 용이
- **단점**
    - 글이 많아질수록 번들 크기 증가
    - 글을 수정하면 반드시 재빌드 필요

```ts
const modules = import.meta.glob('./posts/**/*.md', {
    query: '?raw',
    import: 'default',
    eager: true,
}) as Record<string, string>;

export const posts = Object.entries(modules).map(([path, content]) => {
    const slug = path.replace(/^\.\/posts\//, '').replace(/\.md$/, '');
    return { slug, path, content };
});
```


### 2) 동적 fetch 방식
- **권장 상황**: 글이 많거나 수시로 수정되는 블로그, 문서 사이트
- **장점**
    - 번들 크기 최소화
    - 파일 교체만으로 배포 없이 업데이트 가능
- **단점**
    - 최초 로딩 시 네트워크 요청 필요
    - 별도의 인덱스(manifest) 관리 필요


---

## Markdown 목록과 상세 렌더링

- ### 글 목록

```tsx
import { posts } from './markdown';

export function BlogList() {
    return (
        <ul>
            {posts.map(p => (
                <li key={p.slug}>
                    <a href={`/post/${p.slug}`}>{p.slug}</a>
                </li>
            ))}
        </ul>
    );
}

```

- ### 글 상세보기

```tsx
import { useParams } from 'react-router-dom';
import { posts } from './markdown';
import remarkGfm from 'remark-gfm';
import ReactMarkdown from 'react-markdown';

export function Post() {
    const { slug = '' } = useParams();
    const post = posts.find(p => p.slug === slug);
    if (!post) return <div>Not found</div>;

    return (
        <article className="prose max-w-none">
            <ReactMarkdown remarkPlugins={[remarkGfm]}>
                {post.content}
            </ReactMarkdown>
        </article>
    );
}

```

---

- ### GFM(GitHub Flavored Markdown) 적용
> 체크박스, 표, 취소선 등은 기본 Markdown 사양이 아니라 GFM 기능이므로 별도의 플러그인이 필요합니다.

```bash
npm i remark-gfm
```

```tsx
import remarkGfm from 'remark-gfm';

<ReactMarkdown remarkPlugins={[remarkGfm]}>{md}</ReactMarkdown>;
```

---

### 코드블럭 하이라이팅 (Shiki + rehype-pretty-code)
> Markdown의 코드 블럭을 단순 텍스트가 아니라 구문 강조된 코드로 표현하려면 rehype-pretty-code와 shiki를 함께 사용합니다.

```bash
npm install rehype-pretty-code shiki
```


- ### Shiki 하이라이터 준비

```ts
// shikiHighlighter.ts
import { createHighlighter } from "shiki";
import 테마명 from "shiki/themes/테마명.mjs";
import ts from "shiki/langs/ts.mjs";
import tsx from "shiki/langs/tsx.mjs";
import js from "shiki/langs/javascript.mjs";
// ...언어 추가

let _highlighter: Awaited<ReturnType<typeof createHighlighter>> | null = null;

export async function getShikiHighlighter() {
    if (_highlighter) return _highlighter;
    _highlighter = await createHighlighter({
        themes: [테마명],
        langs: [ts, tsx, js],
    });
    return _highlighter;
}

```

- ### 옵션 정의

```ts
// prettyCodeOptions.ts
import type { Options } from "rehype-pretty-code";
import { getShikiHighlighter } from "./shikiHighlighter";

export const prettyCodeOptions: Options = {
    theme: { light: "테마명", dark: "테마명" },
    keepBackground: true,
    defaultLang: "plaintext",
    getHighlighter: getShikiHighlighter,
};

```

- ### 실제 적용

> `rehype-pretty-code`는 비동기 플러그인이므로 react-markdown의 컴포넌트는 `MarkdownHooks`를 사용해야 합니다.

```tsx
import { MarkdownHooks } from 'react-markdown';
import remarkGfm from "remark-gfm";
import rehypePrettyCode from "rehype-pretty-code";
import { prettyCodeOptions } from "./prettyCodeOptions";

export default function MarkdownViewer({ markdown }: { markdown: string }) {
  return (
      <article className="prose max-w-none">
          <MarkdownHooks
              remarkPlugins={[remarkGfm]}
              rehypePlugins={[[rehypePrettyCode, prettyCodeOptions]]}
              components={{
                  pre: (props) => (
                      <pre {...props} className="rounded-lg overflow-auto" />
                  ),
                  code: (props) => <code {...props} />
              }}
          >
              {markdown}
          </MarkdownHooks>
      </article>
  );
}

```

---

- ### 적용 과정

  1. react-markdown, remark-gfm, rehype-pretty-code, shiki 라이브러리를 설치합니다.
  2. 마크다운 파일을 정적 import(?raw) 또는 동적 fetch 방식으로 불러옵니다.
  3. remark-gfm을 적용하여 체크박스, 표 등 GFM 문법을 지원합니다.
  4. rehype-pretty-code와 shiki를 통해 코드 블럭에 하이라이팅을 적용합니다.
  5. TailwindCSS의 prose 클래스나 커스텀 CSS로 스타일을 다듬습니다.

- ### 결과

  - 일반 텍스트뿐 아니라 표, 체크박스, 취소선 등 GFM 문법이 정상적으로 렌더링됩니다.
  - 코드 블럭은 Shiki 테마가 적용되어 가독성이 크게 향상됩니다.
  - 마크다운 기반 블로그나 문서 페이지에서 정적 import 방식은 소규모 문서에, fetch 방식은 대규모 블로그/위키에 적합합니다.

---

## 마무리하며

이번 글에서는 react-markdown을 기반으로 마크다운 렌더링을 구현하고,  
remark-gfm과 rehype-pretty-code를 통해 확장 기능 및 코드 하이라이팅을 적용하는 방법을 살펴보았습니다.

기본 Markdown 렌더링에서 한 단계 나아가, 실제 블로그나 문서 사이트에서 읽기 좋은 콘텐츠를 만드는 데 도움이 되기를 바랍니다.

감사합니다.